// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.2.2

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type ScheduleHTTPServer interface {
	CreateSchedule(context.Context, *CreateScheduleRequest) (*CreateScheduleReply, error)
	DeleteSchedule(context.Context, *DeleteScheduleRequest) (*DeleteScheduleReply, error)
	GetSchedule(context.Context, *GetScheduleRequest) (*GetScheduleReply, error)
	ListSchedule(context.Context, *ListScheduleRequest) (*ListScheduleReply, error)
	LockSchedule(context.Context, *LockScheduleRequest) (*LockScheduleReply, error)
	UnlockSchedule(context.Context, *UnlockScheduleRequest) (*UnlockScheduleReply, error)
	UpdateSchedule(context.Context, *UpdateScheduleRequest) (*UpdateScheduleReply, error)
}

func RegisterScheduleHTTPServer(s *http.Server, srv ScheduleHTTPServer) {
	r := s.Route("/")
	r.POST("/api/v1/schedule", _Schedule_CreateSchedule0_HTTP_Handler(srv))
	r.POST("/api/v1/schedule/update", _Schedule_UpdateSchedule0_HTTP_Handler(srv))
	r.DELETE("/api/v1/schedule/{id}", _Schedule_DeleteSchedule0_HTTP_Handler(srv))
	r.GET("/api/v1/schedule/{id}", _Schedule_GetSchedule0_HTTP_Handler(srv))
	r.GET("/api/v1/schedules/list", _Schedule_ListSchedule0_HTTP_Handler(srv))
	r.GET("/api/v1/schedule/lock/{id}", _Schedule_LockSchedule0_HTTP_Handler(srv))
	r.GET("/api/v1/schedule/unlock/{id}", _Schedule_UnlockSchedule0_HTTP_Handler(srv))
}

func _Schedule_CreateSchedule0_HTTP_Handler(srv ScheduleHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateScheduleRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.schedule.v1.Schedule/CreateSchedule")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateSchedule(ctx, req.(*CreateScheduleRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateScheduleReply)
		return ctx.Result(200, reply)
	}
}

func _Schedule_UpdateSchedule0_HTTP_Handler(srv ScheduleHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateScheduleRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.schedule.v1.Schedule/UpdateSchedule")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateSchedule(ctx, req.(*UpdateScheduleRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateScheduleReply)
		return ctx.Result(200, reply)
	}
}

func _Schedule_DeleteSchedule0_HTTP_Handler(srv ScheduleHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteScheduleRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.schedule.v1.Schedule/DeleteSchedule")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteSchedule(ctx, req.(*DeleteScheduleRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteScheduleReply)
		return ctx.Result(200, reply)
	}
}

func _Schedule_GetSchedule0_HTTP_Handler(srv ScheduleHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetScheduleRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.schedule.v1.Schedule/GetSchedule")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetSchedule(ctx, req.(*GetScheduleRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetScheduleReply)
		return ctx.Result(200, reply)
	}
}

func _Schedule_ListSchedule0_HTTP_Handler(srv ScheduleHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListScheduleRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.schedule.v1.Schedule/ListSchedule")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListSchedule(ctx, req.(*ListScheduleRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListScheduleReply)
		return ctx.Result(200, reply)
	}
}

func _Schedule_LockSchedule0_HTTP_Handler(srv ScheduleHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LockScheduleRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.schedule.v1.Schedule/LockSchedule")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.LockSchedule(ctx, req.(*LockScheduleRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LockScheduleReply)
		return ctx.Result(200, reply)
	}
}

func _Schedule_UnlockSchedule0_HTTP_Handler(srv ScheduleHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UnlockScheduleRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.schedule.v1.Schedule/UnlockSchedule")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UnlockSchedule(ctx, req.(*UnlockScheduleRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UnlockScheduleReply)
		return ctx.Result(200, reply)
	}
}

type ScheduleHTTPClient interface {
	CreateSchedule(ctx context.Context, req *CreateScheduleRequest, opts ...http.CallOption) (rsp *CreateScheduleReply, err error)
	DeleteSchedule(ctx context.Context, req *DeleteScheduleRequest, opts ...http.CallOption) (rsp *DeleteScheduleReply, err error)
	GetSchedule(ctx context.Context, req *GetScheduleRequest, opts ...http.CallOption) (rsp *GetScheduleReply, err error)
	ListSchedule(ctx context.Context, req *ListScheduleRequest, opts ...http.CallOption) (rsp *ListScheduleReply, err error)
	LockSchedule(ctx context.Context, req *LockScheduleRequest, opts ...http.CallOption) (rsp *LockScheduleReply, err error)
	UnlockSchedule(ctx context.Context, req *UnlockScheduleRequest, opts ...http.CallOption) (rsp *UnlockScheduleReply, err error)
	UpdateSchedule(ctx context.Context, req *UpdateScheduleRequest, opts ...http.CallOption) (rsp *UpdateScheduleReply, err error)
}

type ScheduleHTTPClientImpl struct {
	cc *http.Client
}

func NewScheduleHTTPClient(client *http.Client) ScheduleHTTPClient {
	return &ScheduleHTTPClientImpl{client}
}

func (c *ScheduleHTTPClientImpl) CreateSchedule(ctx context.Context, in *CreateScheduleRequest, opts ...http.CallOption) (*CreateScheduleReply, error) {
	var out CreateScheduleReply
	pattern := "/api/v1/schedule"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.schedule.v1.Schedule/CreateSchedule"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ScheduleHTTPClientImpl) DeleteSchedule(ctx context.Context, in *DeleteScheduleRequest, opts ...http.CallOption) (*DeleteScheduleReply, error) {
	var out DeleteScheduleReply
	pattern := "/api/v1/schedule/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.schedule.v1.Schedule/DeleteSchedule"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ScheduleHTTPClientImpl) GetSchedule(ctx context.Context, in *GetScheduleRequest, opts ...http.CallOption) (*GetScheduleReply, error) {
	var out GetScheduleReply
	pattern := "/api/v1/schedule/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.schedule.v1.Schedule/GetSchedule"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ScheduleHTTPClientImpl) ListSchedule(ctx context.Context, in *ListScheduleRequest, opts ...http.CallOption) (*ListScheduleReply, error) {
	var out ListScheduleReply
	pattern := "/api/v1/schedules/list"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.schedule.v1.Schedule/ListSchedule"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ScheduleHTTPClientImpl) LockSchedule(ctx context.Context, in *LockScheduleRequest, opts ...http.CallOption) (*LockScheduleReply, error) {
	var out LockScheduleReply
	pattern := "/api/v1/schedule/lock/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.schedule.v1.Schedule/LockSchedule"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ScheduleHTTPClientImpl) UnlockSchedule(ctx context.Context, in *UnlockScheduleRequest, opts ...http.CallOption) (*UnlockScheduleReply, error) {
	var out UnlockScheduleReply
	pattern := "/api/v1/schedule/unlock/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.schedule.v1.Schedule/UnlockSchedule"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ScheduleHTTPClientImpl) UpdateSchedule(ctx context.Context, in *UpdateScheduleRequest, opts ...http.CallOption) (*UpdateScheduleReply, error) {
	var out UpdateScheduleReply
	pattern := "/api/v1/schedule/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.schedule.v1.Schedule/UpdateSchedule"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
