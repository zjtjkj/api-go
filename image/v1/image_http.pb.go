// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.2.0

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

type ImageHTTPServer interface {
	CreateImage(context.Context, *CreateImageRequest) (*CreateImageReply, error)
	DeleteImage(context.Context, *DeleteImageRequest) (*DeleteImageReply, error)
	GetImage(context.Context, *GetImageRequest) (*GetImageReply, error)
	GetImageByNameVersion(context.Context, *GetImageByNameVersionRequest) (*GetImageByNameVersionReply, error)
	ListImage(context.Context, *ListImageRequest) (*ListImageReply, error)
	UpdateImage(context.Context, *UpdateImageRequest) (*UpdateImageReply, error)
}

func RegisterImageHTTPServer(s *http.Server, srv ImageHTTPServer) {
	r := s.Route("/")
	r.POST("/api/v1/image", _Image_CreateImage0_HTTP_Handler(srv))
	r.PUT("/api/v1/image/{id}", _Image_UpdateImage0_HTTP_Handler(srv))
	r.DELETE("/api/v1/image/{id}", _Image_DeleteImage0_HTTP_Handler(srv))
	r.GET("/api/v1/image/{id}", _Image_GetImage0_HTTP_Handler(srv))
	r.GET("/api/v1/image/{name}/{version}", _Image_GetImageByNameVersion0_HTTP_Handler(srv))
	r.GET("/api/v1/image", _Image_ListImage0_HTTP_Handler(srv))
}

func _Image_CreateImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.image.v1.Image/CreateImage")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateImage(ctx, req.(*CreateImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_UpdateImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.image.v1.Image/UpdateImage")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateImage(ctx, req.(*UpdateImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_DeleteImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteImageRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.image.v1.Image/DeleteImage")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteImage(ctx, req.(*DeleteImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_GetImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetImageRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.image.v1.Image/GetImage")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetImage(ctx, req.(*GetImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_GetImageByNameVersion0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetImageByNameVersionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.image.v1.Image/GetImageByNameVersion")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetImageByNameVersion(ctx, req.(*GetImageByNameVersionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetImageByNameVersionReply)
		return ctx.Result(200, reply)
	}
}

func _Image_ListImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListImageRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, "/api.image.v1.Image/ListImage")
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListImage(ctx, req.(*ListImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListImageReply)
		return ctx.Result(200, reply)
	}
}

type ImageHTTPClient interface {
	CreateImage(ctx context.Context, req *CreateImageRequest, opts ...http.CallOption) (rsp *CreateImageReply, err error)
	DeleteImage(ctx context.Context, req *DeleteImageRequest, opts ...http.CallOption) (rsp *DeleteImageReply, err error)
	GetImage(ctx context.Context, req *GetImageRequest, opts ...http.CallOption) (rsp *GetImageReply, err error)
	GetImageByNameVersion(ctx context.Context, req *GetImageByNameVersionRequest, opts ...http.CallOption) (rsp *GetImageByNameVersionReply, err error)
	ListImage(ctx context.Context, req *ListImageRequest, opts ...http.CallOption) (rsp *ListImageReply, err error)
	UpdateImage(ctx context.Context, req *UpdateImageRequest, opts ...http.CallOption) (rsp *UpdateImageReply, err error)
}

type ImageHTTPClientImpl struct {
	cc *http.Client
}

func NewImageHTTPClient(client *http.Client) ImageHTTPClient {
	return &ImageHTTPClientImpl{client}
}

func (c *ImageHTTPClientImpl) CreateImage(ctx context.Context, in *CreateImageRequest, opts ...http.CallOption) (*CreateImageReply, error) {
	var out CreateImageReply
	pattern := "/api/v1/image"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.image.v1.Image/CreateImage"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) DeleteImage(ctx context.Context, in *DeleteImageRequest, opts ...http.CallOption) (*DeleteImageReply, error) {
	var out DeleteImageReply
	pattern := "/api/v1/image/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.image.v1.Image/DeleteImage"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) GetImage(ctx context.Context, in *GetImageRequest, opts ...http.CallOption) (*GetImageReply, error) {
	var out GetImageReply
	pattern := "/api/v1/image/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.image.v1.Image/GetImage"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) GetImageByNameVersion(ctx context.Context, in *GetImageByNameVersionRequest, opts ...http.CallOption) (*GetImageByNameVersionReply, error) {
	var out GetImageByNameVersionReply
	pattern := "/api/v1/image/{name}/{version}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.image.v1.Image/GetImageByNameVersion"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) ListImage(ctx context.Context, in *ListImageRequest, opts ...http.CallOption) (*ListImageReply, error) {
	var out ListImageReply
	pattern := "/api/v1/image"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation("/api.image.v1.Image/ListImage"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) UpdateImage(ctx context.Context, in *UpdateImageRequest, opts ...http.CallOption) (*UpdateImageReply, error) {
	var out UpdateImageReply
	pattern := "/api/v1/image/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation("/api.image.v1.Image/UpdateImage"))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
