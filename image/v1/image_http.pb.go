// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// protoc-gen-go-http v2.3.1

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationImageCreateImage = "/api.image.v1.Image/CreateImage"
const OperationImageUpdateImage = "/api.image.v1.Image/UpdateImage"
const OperationImageDeleteImage = "/api.image.v1.Image/DeleteImage"
const OperationImageGetImage = "/api.image.v1.Image/GetImage"
const OperationImageGetImageByNameVersion = "/api.image.v1.Image/GetImageByNameVersion"
const OperationImageListImage = "/api.image.v1.Image/ListImage"
const OperationImageListAvailableImage = "/api.image.v1.Image/ListAvailableImage"
const OperationImageListAvailableImageByName = "/api.image.v1.Image/ListAvailableImageByName"
const OperationImageLockImage = "/api.image.v1.Image/LockImage"
const OperationImageUnlockImage = "/api.image.v1.Image/UnlockImage"

type ImageHTTPServer interface {
	CreateImage(context.Context, *CreateImageRequest) (*CreateImageReply, error)
	DeleteImage(context.Context, *DeleteImageRequest) (*DeleteImageReply, error)
	GetImage(context.Context, *GetImageRequest) (*GetImageReply, error)
	GetImageByNameVersion(context.Context, *GetImageByNameVersionRequest) (*GetImageByNameVersionReply, error)
	ListAvailableImage(context.Context, *ListAvailableImageRequest) (*ListAvailableImageReply, error)
	ListAvailableImageByName(context.Context, *ListAvailableImageByNameRequest) (*ListAvailableImageByNameReply, error)
	ListImage(context.Context, *ListImageRequest) (*ListImageReply, error)
	LockImage(context.Context, *LockImageRequest) (*LockImageReply, error)
	UnlockImage(context.Context, *UnlockImageRequest) (*UnlockImageReply, error)
	UpdateImage(context.Context, *UpdateImageRequest) (*UpdateImageReply, error)
}

func RegisterImageHTTPServer(s *http.Server, srv ImageHTTPServer) {
	r := s.Route("/")
	r.POST("/api/v1/image", _Image_CreateImage0_HTTP_Handler(srv))
	r.PUT("/api/v1/image/{id}", _Image_UpdateImage0_HTTP_Handler(srv))
	r.DELETE("/api/v1/image/{id}", _Image_DeleteImage0_HTTP_Handler(srv))
	r.GET("/api/v1/image/{id}", _Image_GetImage0_HTTP_Handler(srv))
	r.GET("/api/v1/image/{name}/{version}", _Image_GetImageByNameVersion0_HTTP_Handler(srv))
	r.GET("/api/v1/image", _Image_ListImage0_HTTP_Handler(srv))
	r.GET("/api/v1/image/available", _Image_ListAvailableImage0_HTTP_Handler(srv))
	r.GET("/api/v1/image/available/{name}", _Image_ListAvailableImageByName0_HTTP_Handler(srv))
	r.POST("/api/v1/image/lock/{id}", _Image_LockImage0_HTTP_Handler(srv))
	r.POST("/api/v1/image/unlock/{id}", _Image_UnlockImage0_HTTP_Handler(srv))
}

func _Image_CreateImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageCreateImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateImage(ctx, req.(*CreateImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_UpdateImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageUpdateImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateImage(ctx, req.(*UpdateImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_DeleteImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteImageRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageDeleteImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteImage(ctx, req.(*DeleteImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_GetImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetImageRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageGetImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetImage(ctx, req.(*GetImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_GetImageByNameVersion0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetImageByNameVersionRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageGetImageByNameVersion)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetImageByNameVersion(ctx, req.(*GetImageByNameVersionRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetImageByNameVersionReply)
		return ctx.Result(200, reply)
	}
}

func _Image_ListImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListImageRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageListImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListImage(ctx, req.(*ListImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_ListAvailableImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListAvailableImageRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageListAvailableImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListAvailableImage(ctx, req.(*ListAvailableImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListAvailableImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_ListAvailableImageByName0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListAvailableImageByNameRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageListAvailableImageByName)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListAvailableImageByName(ctx, req.(*ListAvailableImageByNameRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListAvailableImageByNameReply)
		return ctx.Result(200, reply)
	}
}

func _Image_LockImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LockImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageLockImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.LockImage(ctx, req.(*LockImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LockImageReply)
		return ctx.Result(200, reply)
	}
}

func _Image_UnlockImage0_HTTP_Handler(srv ImageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UnlockImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageUnlockImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UnlockImage(ctx, req.(*UnlockImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UnlockImageReply)
		return ctx.Result(200, reply)
	}
}

type ImageHTTPClient interface {
	CreateImage(ctx context.Context, req *CreateImageRequest, opts ...http.CallOption) (rsp *CreateImageReply, err error)
	DeleteImage(ctx context.Context, req *DeleteImageRequest, opts ...http.CallOption) (rsp *DeleteImageReply, err error)
	GetImage(ctx context.Context, req *GetImageRequest, opts ...http.CallOption) (rsp *GetImageReply, err error)
	GetImageByNameVersion(ctx context.Context, req *GetImageByNameVersionRequest, opts ...http.CallOption) (rsp *GetImageByNameVersionReply, err error)
	ListAvailableImage(ctx context.Context, req *ListAvailableImageRequest, opts ...http.CallOption) (rsp *ListAvailableImageReply, err error)
	ListAvailableImageByName(ctx context.Context, req *ListAvailableImageByNameRequest, opts ...http.CallOption) (rsp *ListAvailableImageByNameReply, err error)
	ListImage(ctx context.Context, req *ListImageRequest, opts ...http.CallOption) (rsp *ListImageReply, err error)
	LockImage(ctx context.Context, req *LockImageRequest, opts ...http.CallOption) (rsp *LockImageReply, err error)
	UnlockImage(ctx context.Context, req *UnlockImageRequest, opts ...http.CallOption) (rsp *UnlockImageReply, err error)
	UpdateImage(ctx context.Context, req *UpdateImageRequest, opts ...http.CallOption) (rsp *UpdateImageReply, err error)
}

type ImageHTTPClientImpl struct {
	cc *http.Client
}

func NewImageHTTPClient(client *http.Client) ImageHTTPClient {
	return &ImageHTTPClientImpl{client}
}

func (c *ImageHTTPClientImpl) CreateImage(ctx context.Context, in *CreateImageRequest, opts ...http.CallOption) (*CreateImageReply, error) {
	var out CreateImageReply
	pattern := "/api/v1/image"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationImageCreateImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) DeleteImage(ctx context.Context, in *DeleteImageRequest, opts ...http.CallOption) (*DeleteImageReply, error) {
	var out DeleteImageReply
	pattern := "/api/v1/image/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationImageDeleteImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) GetImage(ctx context.Context, in *GetImageRequest, opts ...http.CallOption) (*GetImageReply, error) {
	var out GetImageReply
	pattern := "/api/v1/image/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationImageGetImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) GetImageByNameVersion(ctx context.Context, in *GetImageByNameVersionRequest, opts ...http.CallOption) (*GetImageByNameVersionReply, error) {
	var out GetImageByNameVersionReply
	pattern := "/api/v1/image/{name}/{version}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationImageGetImageByNameVersion))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) ListAvailableImage(ctx context.Context, in *ListAvailableImageRequest, opts ...http.CallOption) (*ListAvailableImageReply, error) {
	var out ListAvailableImageReply
	pattern := "/api/v1/image/available"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationImageListAvailableImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) ListAvailableImageByName(ctx context.Context, in *ListAvailableImageByNameRequest, opts ...http.CallOption) (*ListAvailableImageByNameReply, error) {
	var out ListAvailableImageByNameReply
	pattern := "/api/v1/image/available/{name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationImageListAvailableImageByName))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) ListImage(ctx context.Context, in *ListImageRequest, opts ...http.CallOption) (*ListImageReply, error) {
	var out ListImageReply
	pattern := "/api/v1/image"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationImageListImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) LockImage(ctx context.Context, in *LockImageRequest, opts ...http.CallOption) (*LockImageReply, error) {
	var out LockImageReply
	pattern := "/api/v1/image/lock/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationImageLockImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) UnlockImage(ctx context.Context, in *UnlockImageRequest, opts ...http.CallOption) (*UnlockImageReply, error) {
	var out UnlockImageReply
	pattern := "/api/v1/image/unlock/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationImageUnlockImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ImageHTTPClientImpl) UpdateImage(ctx context.Context, in *UpdateImageRequest, opts ...http.CallOption) (*UpdateImageReply, error) {
	var out UpdateImageReply
	pattern := "/api/v1/image/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationImageUpdateImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
